/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package proyecto_sv;

/**
 * @author Alessandro Gramcko
 * @author massimo Gramcko
 */

import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.table.DefaultTableModel;
import java.awt.Color;
import javax.swing.JPanel;
import javax.swing.BorderFactory;

public class VentanaPrincipal extends javax.swing.JFrame {

    // Esta es la variable que controlará todo el backend
    private Simulador simulador;
    
   public VentanaPrincipal() {
    
    initComponents();
    
    // Creamos la instancia del "cerebro"
    this.simulador = new Simulador();

    // Establecemos el layout del disco
    int totalBloquesDisco = 100; 
    int filas = (int) Math.ceil(Math.sqrt(totalBloquesDisco));
    int columnas = filas;
    panelDisco.setLayout(new java.awt.GridLayout(filas, columnas, 2, 2));
    
    // --- INICIA EL RELOJ DEL SIMULADOR (TIMER) ---
    javax.swing.Timer timer = new javax.swing.Timer(2000, new java.awt.event.ActionListener() {
        
        @Override
        public void actionPerformed(java.awt.event.ActionEvent e) {
            // CADA "TICK" DEL RELOJ, hacemos dos cosas:
            
            // 1. Le decimos al simulador que ejecute UNA operación
            simulador.ejecutarTickPlanificador();
            
            // 2. Actualizamos TODA la GUI para reflejar los cambios
            actualizarGUICompleta();
            actualizarPermisosGUI();
            
            
        }
    });
    
    timer.start(); // ¡Inicia el reloj!
    
    this.addWindowListener(new java.awt.event.WindowAdapter() {
        @Override
        public void windowClosing(java.awt.event.WindowEvent e) {
            
            // Justo antes de que la ventana se cierre...
            System.out.println("GUI: Guardando estado antes de salir...");
            
            // ¡Llamamos al método de guardar!
            simulador.guardarEstado();
            
            // (Después de esto, el programa se cerrará normalmente
            //  gracias a la propiedad 'defaultCloseOperation')
        }
    });
    // --- FIN DEL RELOJ ---
}

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        splitPanePrincipal = new javax.swing.JSplitPane();
        scrollArbol = new javax.swing.JScrollPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        arbolArchivos = new javax.swing.JTree();
        splitPaneDerecho = new javax.swing.JSplitPane();
        splitPaneVisuals = new javax.swing.JSplitPane();
        scrollDisco = new javax.swing.JScrollPane();
        panelDisco = new javax.swing.JPanel();
        scrollTabla = new javax.swing.JScrollPane();
        jScrollPane2 = new javax.swing.JScrollPane();
        tablaAsignacion = new javax.swing.JTable();
        panelControlesGeneral = new javax.swing.JPanel();
        panelAcciones = new javax.swing.JPanel();
        lblNombre = new javax.swing.JLabel();
        txtNombreArchivo = new javax.swing.JTextField();
        lblTamano = new javax.swing.JLabel();
        spinnerTamano = new javax.swing.JSpinner();
        btnCrearArchivo = new javax.swing.JButton();
        btnEliminarArchivo = new javax.swing.JButton();
        panelSistema = new javax.swing.JPanel();
        comboPolitica = new javax.swing.JComboBox<>();
        jLabel1 = new javax.swing.JLabel();
        radioAdmin = new javax.swing.JRadioButton();
        radioUsuario = new javax.swing.JRadioButton();
        scrollColas = new javax.swing.JScrollPane();
        areaColasProcesos = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        splitPanePrincipal.setResizeWeight(0.3);

        jScrollPane1.setViewportView(arbolArchivos);

        scrollArbol.setViewportView(jScrollPane1);

        splitPanePrincipal.setLeftComponent(scrollArbol);

        splitPaneDerecho.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
        splitPaneDerecho.setResizeWeight(0.6);

        scrollDisco.setBorder(javax.swing.BorderFactory.createTitledBorder("Disco SD"));

        javax.swing.GroupLayout panelDiscoLayout = new javax.swing.GroupLayout(panelDisco);
        panelDisco.setLayout(panelDiscoLayout);
        panelDiscoLayout.setHorizontalGroup(
            panelDiscoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );
        panelDiscoLayout.setVerticalGroup(
            panelDiscoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 408, Short.MAX_VALUE)
        );

        scrollDisco.setViewportView(panelDisco);

        splitPaneVisuals.setLeftComponent(scrollDisco);

        scrollTabla.setBorder(javax.swing.BorderFactory.createTitledBorder("Tabla de Asignación"));

        tablaAsignacion.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Nombre", "Tamaño (Bloques)", "Bloque Inicial"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.Integer.class, java.lang.Integer.class
            };
            boolean[] canEdit = new boolean [] {
                false, false, false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        jScrollPane2.setViewportView(tablaAsignacion);

        scrollTabla.setViewportView(jScrollPane2);

        splitPaneVisuals.setRightComponent(scrollTabla);

        splitPaneDerecho.setTopComponent(splitPaneVisuals);

        panelControlesGeneral.setLayout(new javax.swing.BoxLayout(panelControlesGeneral, javax.swing.BoxLayout.LINE_AXIS));

        panelAcciones.setBorder(javax.swing.BorderFactory.createTitledBorder("Acciones"));

        lblNombre.setText("Nombre:");

        txtNombreArchivo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                txtNombreArchivoActionPerformed(evt);
            }
        });

        lblTamano.setText("Tamaño (Bloques):");

        spinnerTamano.setModel(new javax.swing.SpinnerNumberModel(1, 1, null, 1));

        btnCrearArchivo.setText("Crear Archivo");
        btnCrearArchivo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCrearArchivoActionPerformed(evt);
            }
        });

        btnEliminarArchivo.setText("Eliminar Archivo");
        btnEliminarArchivo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnEliminarArchivoActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout panelAccionesLayout = new javax.swing.GroupLayout(panelAcciones);
        panelAcciones.setLayout(panelAccionesLayout);
        panelAccionesLayout.setHorizontalGroup(
            panelAccionesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(btnCrearArchivo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(panelAccionesLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelAccionesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(panelAccionesLayout.createSequentialGroup()
                        .addComponent(lblTamano, javax.swing.GroupLayout.PREFERRED_SIZE, 112, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(spinnerTamano))
                    .addGroup(panelAccionesLayout.createSequentialGroup()
                        .addComponent(lblNombre, javax.swing.GroupLayout.PREFERRED_SIZE, 56, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtNombreArchivo, javax.swing.GroupLayout.PREFERRED_SIZE, 103, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(77, Short.MAX_VALUE))
            .addComponent(btnEliminarArchivo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        panelAccionesLayout.setVerticalGroup(
            panelAccionesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelAccionesLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelAccionesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblNombre)
                    .addComponent(txtNombreArchivo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addGroup(panelAccionesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblTamano)
                    .addComponent(spinnerTamano, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 157, Short.MAX_VALUE)
                .addComponent(btnCrearArchivo)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(btnEliminarArchivo)
                .addGap(28, 28, 28))
        );

        panelControlesGeneral.add(panelAcciones);

        panelSistema.setBorder(javax.swing.BorderFactory.createTitledBorder("Sistema"));

        comboPolitica.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "FIFO", "SSTF", "SCAN", "C-SCAN" }));
        comboPolitica.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                comboPoliticaActionPerformed(evt);
            }
        });

        jLabel1.setText("Política:");

        buttonGroup1.add(radioAdmin);
        radioAdmin.setText("Modo Administrador");
        radioAdmin.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                radioAdminActionPerformed(evt);
            }
        });

        buttonGroup1.add(radioUsuario);
        radioUsuario.setText("Modo Usuario");
        radioUsuario.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                radioUsuarioActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout panelSistemaLayout = new javax.swing.GroupLayout(panelSistema);
        panelSistema.setLayout(panelSistemaLayout);
        panelSistemaLayout.setHorizontalGroup(
            panelSistemaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelSistemaLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelSistemaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(radioUsuario)
                    .addComponent(radioAdmin)
                    .addGroup(panelSistemaLayout.createSequentialGroup()
                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(comboPolitica, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(118, Short.MAX_VALUE))
        );
        panelSistemaLayout.setVerticalGroup(
            panelSistemaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelSistemaLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelSistemaLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(comboPolitica, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addGap(18, 18, 18)
                .addComponent(radioAdmin)
                .addGap(18, 18, 18)
                .addComponent(radioUsuario)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        panelControlesGeneral.add(panelSistema);

        scrollColas.setBorder(javax.swing.BorderFactory.createTitledBorder("Colas"));

        areaColasProcesos.setColumns(20);
        areaColasProcesos.setRows(5);
        scrollColas.setViewportView(areaColasProcesos);

        panelControlesGeneral.add(scrollColas);

        splitPaneDerecho.setRightComponent(panelControlesGeneral);

        splitPanePrincipal.setRightComponent(splitPaneDerecho);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(splitPanePrincipal, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 939, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(splitPanePrincipal, javax.swing.GroupLayout.PREFERRED_SIZE, 642, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 132, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void txtNombreArchivoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_txtNombreArchivoActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_txtNombreArchivoActionPerformed

    private void btnCrearArchivoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCrearArchivoActionPerformed
       // 1. Obtenemos los datos de la GUI
    // (Usa los nombres de variable que definiste)
    String nombre = txtNombreArchivo.getText(); 
    int tamano = (Integer) spinnerTamano.getValue(); 

    // 2. Validamos la entrada
    if (nombre == null || nombre.trim().isEmpty()) {
        javax.swing.JOptionPane.showMessageDialog(this, "Debe ingresar un nombre de archivo.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
        return;
    }
    
    // (El JSpinner ya valida que el tamaño sea >= 1, si lo configuraste bien)
    
    // 3. ¡¡LA PARTE CLAVE!!
    // NO creamos el archivo aquí.
    // Le pedimos al SIMULADOR que "encole" la solicitud.
    
    simulador.nuevaSolicitudUsuario(
        TipoOperacion.CREAR_ARCHIVO, 
        nombre, 
        tamano
    );
    
    // 4. (Opcional) Limpiamos los campos
    txtNombreArchivo.setText("");
    spinnerTamano.setValue(1);
    
    System.out.println("GUI: Solicitud para CREAR '" + nombre + "' fue encolada.");
    
    // --- ¡¡LÍNEA AÑADIDA!! ---
    // Actualizamos la GUI INMEDIATAMENTE para ver la cola "en espera"
    actualizarGUICompleta();
    }//GEN-LAST:event_btnCrearArchivoActionPerformed

    private void btnEliminarArchivoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnEliminarArchivoActionPerformed
       // 1. Obtener el nombre del archivo del JTree
    // (Forma simple: usar el mismo campo de texto de "Nombre")
    String nombre = txtNombreArchivo.getText();

    // (Forma avanzada: ...)
    // ...
    
    if (nombre == null || nombre.trim().isEmpty()) {
        javax.swing.JOptionPane.showMessageDialog(this, "Debe ingresar un nombre de archivo para eliminar.", "Error", javax.swing.JOptionPane.ERROR_MESSAGE);
        return;
    }
    
    // 2. ¡LA CLAVE! Pedir al simulador que ENCOLE la solicitud de borrado
    simulador.nuevaSolicitudUsuario(
        TipoOperacion.ELIMINAR_ARCHIVO, 
        nombre, 
        0 // El tamaño no importa para eliminar
    );

    // 3. Limpiar el campo
    txtNombreArchivo.setText("");
    
    System.out.println("GUI: Solicitud para ELIMINAR '" + nombre + "' fue encolada.");
    
    // --- ¡¡LÍNEA AÑADIDA!! ---
    // Actualizamos la GUI INMEDIATAMENTE para ver la cola "en espera"
    actualizarGUICompleta();
    }//GEN-LAST:event_btnEliminarArchivoActionPerformed

    private void radioAdminActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_radioAdminActionPerformed
      simulador.setModo(ModoUsuario.ADMINISTRADOR);
    actualizarPermisosGUI(); // Llamamos al método que actualiza los botones
    }//GEN-LAST:event_radioAdminActionPerformed

    private void radioUsuarioActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_radioUsuarioActionPerformed
      simulador.setModo(ModoUsuario.USUARIO);
    actualizarPermisosGUI(); // Llamamos al método que actualiza los botones
    }//GEN-LAST:event_radioUsuarioActionPerformed

    private void comboPoliticaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_comboPoliticaActionPerformed
        // 1. Obtener el texto seleccionado (ej. "FIFO", "SSTF")
    String seleccion = (String) comboPolitica.getSelectedItem();

    // 2. Convertir el texto a nuestro enum
    switch (seleccion) {
        case "FIFO":
            simulador.setPolitica(PoliticaPlanificacion.FIFO);
            break;
        case "SSTF":
            simulador.setPolitica(PoliticaPlanificacion.SSTF);
            break;
        case "SCAN":
            simulador.setPolitica(PoliticaPlanificacion.SCAN);
            break;
        case "C-SCAN":
            simulador.setPolitica(PoliticaPlanificacion.C_SCAN);
            break;
    }

    System.out.println("GUI: Política cambiada a " + simulador.getPolitica());
    }//GEN-LAST:event_comboPoliticaActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* ... (todo el código 'try-catch' de look and feel) ... */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(VentanaPrincipal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(VentanaPrincipal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(VentanaPrincipal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(VentanaPrincipal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                // ¡Así de simple!
                new VentanaPrincipal().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTree arbolArchivos;
    private javax.swing.JTextArea areaColasProcesos;
    private javax.swing.JButton btnCrearArchivo;
    private javax.swing.JButton btnEliminarArchivo;
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JComboBox<String> comboPolitica;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JLabel lblNombre;
    private javax.swing.JLabel lblTamano;
    private javax.swing.JPanel panelAcciones;
    private javax.swing.JPanel panelControlesGeneral;
    private javax.swing.JPanel panelDisco;
    private javax.swing.JPanel panelSistema;
    private javax.swing.JRadioButton radioAdmin;
    private javax.swing.JRadioButton radioUsuario;
    private javax.swing.JScrollPane scrollArbol;
    private javax.swing.JScrollPane scrollColas;
    private javax.swing.JScrollPane scrollDisco;
    private javax.swing.JScrollPane scrollTabla;
    private javax.swing.JSpinner spinnerTamano;
    private javax.swing.JSplitPane splitPaneDerecho;
    private javax.swing.JSplitPane splitPanePrincipal;
    private javax.swing.JSplitPane splitPaneVisuals;
    private javax.swing.JTable tablaAsignacion;
    private javax.swing.JTextField txtNombreArchivo;
    // End of variables declaration//GEN-END:variables

// --- INICIO MÉTODOS DE ACTUALIZACIÓN DE GUI ---

/**
 * Método "mágico" que lee todo el estado del Simulador
 * y lo dibuja en los componentes de la GUI.
 */
private void actualizarGUICompleta() {
    System.out.println("GUI: Actualizando vistas...");
    
    // 1. Actualizar el Árbol (JTree)
    actualizarArbol();
    
    // 2. Actualizar la Tabla de Asignación (JTable)
    actualizarTablaAsignacion();
    
    // 3. Actualizar la Vista del Disco (JPanel)
    actualizarVistaDisco();
    
    // 4. Actualizar la Vista de Colas (JTextArea)
    actualizarVistaColas();
}

/**
 * Tarea: Leer el Árbol del Simulador y dibujarlo en el JTree
 */
private void actualizarArbol() {
    
    try {
        // 1. Obtener el directorio raíz de NUESTRO backend
        Directorio raizBackend = simulador.getSistemaArchivos().getRaiz();
        if (raizBackend == null) return;

        // 2. Crear el nodo RAÍZ del árbol de SWING
        // El texto que muestra es el nombre de nuestro directorio raíz (ej. "root")
        DefaultMutableTreeNode raizSwing = new DefaultMutableTreeNode(raizBackend.getNombre());

        // 3. Llamar al método recursivo para construir el resto del árbol
        construirNodosArbol(raizBackend, raizSwing);

        // 4. Crear un nuevo "Modelo de Árbol" de SWING con nuestra raíz
        DefaultTreeModel modeloArbol = new DefaultTreeModel(raizSwing);

        // 5. ¡LA MAGIA! Asignar el nuevo modelo a nuestro JTree
        arbolArchivos.setModel(modeloArbol);

        // (Opcional pero recomendado) Expandir la raíz para que se vean los archivos
        arbolArchivos.expandRow(0); 
        
    } catch (Exception e) {
        // (Manejo de errores por si algo falla durante la actualización)
        e.printStackTrace();
    }
}

/**
 * Tarea: Recorrer el árbol, encontrar Archivos y listarlos en la JTable
 */
private void actualizarTablaAsignacion() {
    
    // 1. Obtener el modelo de la JTable
    DefaultTableModel modeloTabla = (DefaultTableModel) tablaAsignacion.getModel();

    // 2. Limpiar la tabla de datos anteriores
    modeloTabla.setRowCount(0);

    // 3. Obtener la raíz del sistema de archivos
    Directorio raiz = simulador.getSistemaArchivos().getRaiz();

    // 4. Llamar a la función recursiva para llenar la tabla
    try {
        if (raiz != null) {
            llenarTablaRecursivo(raiz, modeloTabla);
        }
    } catch (Exception e) {
        // (Manejo de errores por si algo falla durante la actualización)
        e.printStackTrace();
    }
}

/**
 * Tarea: Recorrer el DiscoSD y pintar los bloques en el panelDisco
 */
private void actualizarVistaDisco() {
    
    
    // 1. Limpiamos el panel de cualquier bloque viejo
    panelDisco.removeAll();
    
    try {
        // 2. Obtenemos el "backend" del disco
        DiscoSD disco = simulador.getSistemaArchivos().getDisco();
        
        // 3. Recorremos CADA bloque del disco
        for (int i = 0; i < disco.getNumBloquesTotal(); i++) {
            Bloque bloqueActual = disco.getBloque(i);
            
            // 4. Creamos un "cuadrito" (JPanel) para representar el bloque
            JPanel panelBloque = new JPanel();
            
            // 5. Le ponemos un borde para que se vea la cuadrícula
            panelBloque.setBorder(BorderFactory.createLineBorder(Color.GRAY));
            
            // 6. ¡La lógica de pintado!
            if (bloqueActual.estaOcupado()) {
                // Si está ocupado, lo pintamos de rojo
                panelBloque.setBackground(Color.RED);
                
                // (Opcional) Mostrar a quién pertenece
                String tooltip = "Bloque: " + i + " | Archivo: " + bloqueActual.getArchivoPropietario().getNombre();
                panelBloque.setToolTipText(tooltip);
                
            } else {
                // Si está libre, lo pintamos de verde
                panelBloque.setBackground(Color.GREEN);
            }
            
            // 7. Añadimos el "cuadrito" al panel principal
            panelDisco.add(panelBloque);
        }
    } catch (Exception e) {
        // (Manejo de errores por si algo falla durante la actualización)
        e.printStackTrace();
    }
    
    // 8. ¡MUY IMPORTANTE! Forzamos a la GUI a redibujar el panel
    panelDisco.revalidate();
    panelDisco.repaint();
}

/**
 * Tarea: Leer las colas del Simulador y mostrarlas en el JTextArea
 */
private void actualizarVistaColas() {
    
    // 1. Limpiamos el área de texto
    areaColasProcesos.setText(""); // Asumiendo que se llama así

    try {
        // --- 2. Mostrar la Cola de Procesos (Listos) ---
        areaColasProcesos.append("--- Cola de Procesos (Listos) ---\n");
        Cola<Proceso> colaProcesos = simulador.getColaDeProcesos();
        
        if (colaProcesos.estaVacia()) {
            areaColasProcesos.append("(Vacía)\n");
        } else {
            // Recorremos la lista interna para mostrarla
            NodoLista<Proceso> nodoP = colaProcesos.getListaInterna().getInicio();
            while (nodoP != null) {
                Proceso p = nodoP.getDato();
                areaColasProcesos.append(
                    "PID: " + p.getPid() + " (" + p.getSolicitud().getTipo() + ")\n"
                );
                nodoP = nodoP.getSiguiente();
            }
        }

        // --- 3. Mostrar la Cola de E/S (Bloqueados) ---
        areaColasProcesos.append("\n--- Cola de E/S (Disco) ---\n");
        Cola<SolicitudIO> colaIO = simulador.getColaDeIO();

        if (colaIO.estaVacia()) {
            areaColasProcesos.append("(Vacía)\n");
        } else {
            // Recorremos la lista interna
            NodoLista<SolicitudIO> nodoIO = colaIO.getListaInterna().getInicio();
            while (nodoIO != null) {
                SolicitudIO s = nodoIO.getDato();
                areaColasProcesos.append(
                    s.getTipo() + " - " + s.getNombreArchivo() + "\n"
                );
                nodoIO = nodoIO.getSiguiente();
            }
        }
        
    } catch (Exception e) {
        areaColasProcesos.setText("Error al actualizar colas:\n" + e.getMessage());
        e.printStackTrace();
    }
}

// --- FIN MÉTODOS DE ACTUALIZACIÓN DE GUI ---

/**
 * Método auxiliar RECURSIVO para recorrer el árbol de directorios
 * y añadir los archivos encontrados a la tabla.
 */
private void llenarTablaRecursivo(Directorio directorioActual, DefaultTableModel modeloTabla) {
    
    // 1. Obtener la lista de hijos del directorio actual
    ListaEnlazada<NodoArbol> hijos = directorioActual.getHijos();
    if (hijos == null || hijos.estaVacia()) {
        return; // No hay hijos, termina la recursión
    }

    // 2. Recorrer la lista enlazada de hijos
    NodoLista<NodoArbol> nodoActual = hijos.getInicio();
    while (nodoActual != null) {
        
        NodoArbol nodo = nodoActual.getDato();

        // 3. Comprobar el tipo de nodo
        if (nodo instanceof Archivo) {
            // Si es un Archivo, lo añadimos a la tabla
            Archivo archivo = (Archivo) nodo;
            
            // 4. Añadir la fila
            modeloTabla.addRow(new Object[]{
                archivo.getNombre(),
                archivo.getTamanoEnBloques(),
                archivo.getIdPrimerBloque()
                // (El proyecto también pedía el Proceso que lo creó[cite: 21],
                //  podríamos añadirlo después si guardamos esa info)
            });
            
        } else if (nodo instanceof Directorio) {
            // Si es un Directorio, llamamos recursivamente
            llenarTablaRecursivo((Directorio) nodo, modeloTabla);
        }
        
        // 5. Avanzar al siguiente hijo
        nodoActual = nodoActual.getSiguiente();
    }
}

/**
 * Método auxiliar RECURSIVO para construir el árbol visual (JTree)
 * a partir de nuestro árbol de directorios (backend).
 */
private void construirNodosArbol(Directorio dirPadre, DefaultMutableTreeNode nodoSwingPadre) {
    
    // 1. Obtener la lista de hijos del directorio (backend)
    ListaEnlazada<NodoArbol> hijos = dirPadre.getHijos();
    if (hijos == null || hijos.estaVacia()) {
        return; // No hay hijos, termina la recursión
    }

    // 2. Recorrer la lista enlazada de hijos
    NodoLista<NodoArbol> nodoActual = hijos.getInicio();
    while (nodoActual != null) {
        
        NodoArbol hijoBackend = nodoActual.getDato();

        // 3. Crear un nuevo nodo de SWING para este hijo
        DefaultMutableTreeNode nodoSwingHijo = new DefaultMutableTreeNode(hijoBackend.getNombre());
        
        // 4. Añadir el nuevo nodo de SWING al padre de SWING
        nodoSwingPadre.add(nodoSwingHijo);
        
        // 5. Si este hijo es un Directorio, llamamos recursivamente
        if (hijoBackend instanceof Directorio) {
            construirNodosArbol((Directorio) hijoBackend, nodoSwingHijo);
        }
        
        // 6. Avanzar al siguiente hijo
        nodoActual = nodoActual.getSiguiente();
    }
}
/**
 * Revisa el modo actual del simulador y habilita o deshabilita
 * los controles de la GUI (botones) según los permisos.
 */
private void actualizarPermisosGUI() {
    // Obtenemos el modo actual
    ModoUsuario modo = simulador.getModo();

    // Comprobamos si es Administrador
    boolean esAdmin = (modo == ModoUsuario.ADMINISTRADOR);

    // Habilitamos o deshabilitamos los botones
    btnCrearArchivo.setEnabled(esAdmin);
    btnEliminarArchivo.setEnabled(esAdmin);

    // (Puedes añadir otros controles aquí, como modificar, etc.)
}
}
